# Effective Typescript
***

틈틈이 하루 4~5개

***

## `Items`

**1. 타입스크립트와 자바스크립트의 관계 이해**
  - TS는 JS의 `상위집합` ( 모든 JS 프로그램은 TS 프로그램이다 ), TS가 타입을 위한 별도의 문법을 갖는다
  - JS의 런타임동작을 모델링, 런타임 오류를 미리 찾아내지만 타입체커가 모든 오류를 잡을 순 없음
  - JS에 엄격함을 더함

**2. 타입스크립트 설정 이해하기**
  - `tsconfig.json`을 활용하자 -> 동료들이나 도구가 TS 사용 계획을 파악할 수 있음
  - `noImplicitAny` -> 변수들이 미리 정의된 타입을 가져야하는지 여부 정의
  - `strictNullChecks` -> undefined, null가 모든 타입에 허용되는지 여부
  - strict 설정 더 알아보기

**3. 코드 생성과 타입이 관계없음을 이해하기**
  - TS 컴파일러
    - 최신버전으로 활용할 수 있게 구버전 JS를 Transpile
    - 코드의 타입 오류 체크
    - 위 두가지가 `독립적`임을 이해
      - 타입 오류가 있는 코드도 컴파일이 가능
      - 런타임에는 타입체크가 불가능
      - 타입연산은 런타임에 영향을 주지 않음
      - 런타임 타입은 선언된 타입과 다를 수 있음
      - TS 타입으로는 함수를 오버로드 할 수 없음(타입 수준만 가능)
      - TS 타입은 런타임 성능에 영향을 주지 않음

**4. 구조적 타이핑에 익숙해지기**
  - JS는 `Duck typing`기반, TS는 이를 모델링하기 위해 `구조적 타이핑` 사용
  - 클래스도 구조적 타이핑을 따름
  - 구조적 타이핑으로 `유닛 테스트` 편하게 가능, 라이브러리간 `의존성 분리`(ITEM 51)

**5. any타입 지양하기**
  - any의 위험성
    - any타입에는 타입 안정성이 없다
    - 함수 시그니쳐를 무시한다(약속된 파라미터, 리턴)
    - 언어 서비스가 적용되지 않는다(자동완성, 도움말 등)
    - 코드 리팩토링 시 버그를 감춤
    - 타입 설계를 감춤(상태객체의 설계 등, 설계가 명확하게 보이도록 타입을 일일이 작성할 것)
    - 타입시스템의 신뢰도 저하
  - any는 타입체커와 TS 언어 서비스를 무력하 시킨다

**6. 편집기를 사용하여 타입시스템 탐색**
  - `다시 보고 이해할 것`
  - TS 컴파일러(tsc) / TS 서버(tsserver)
  - 편집기에서 ts 언어 서비스를 적극 활용
  - 편집기로 `ts 시스템`, `ts 타입추론` 개념 잡을 것
  - 타입 선언파일을 찾아보는 방법 터득할 것(ts의 동작 모델링 방식 이해)

**7. 타입이 값들의 집합이라 생각할 것**
  - type은 `할당 가능한 값들의 집합`, 무한하거나(number,string) 유한함(boolean, literal)
  - 엄격한 상속관계가 아닌, 벤 다이어그램 식 표현임
  - A는 B를 상속, A는 B에 할당가능, A는 B의 서브타입 -> A는 B의 부분집합

**8. 타입공간과 값 공간의 심벌 구분하기**
  - 타입과 값의 이름이 같을 때, 구분하는 방법 익숙해 질 것
  - type, interface -> type
  - class, enum -> both
  - typeof, this, etc -> 타입과 값에서 다른 목적으로 활용될 수 있음

**9. 타입 단언보다는 타입 선언을 사용하기**
  ```ts
  interface Person{name: string};
  const alice: Person = {name: 'Alice'}; // 타입 선언
  const bob = {name: 'Bob'} as Person; // 타입 단언
  ```
  - 타입선언은 할당되는 값이 인터페이스를 만족하는지 검사, 속성 추가시도 확인
  - 타입단언이 필요한 경우
    - 타입체커의 추론보다 개발자가 판단하는 타입이 더 정확할때 ex) dom 엘리먼트에 대해
    - null 아니면 단언문
  - 화살표 함수의 반환 타입을 명시하는 법을 터득할 것(`다시 보고 이해할 것`)

**10. 객체 래퍼 타입 피하기**
  - JS는 기본형과 객체 타입을 자유롭게 변환함(기본형을 객체로 래핑->메소드 호출->래핑객체 버림)
  - 객체 래퍼 타입이 어떻게 쓰이는지 이해 요망(직접 사용, 인스턴스 생성 지양)
  - ts 객체 래퍼 타입 대신 기본형 타입 사용(String->string, Number->number, Boolean->boolean etc)

**11. 잉여 속성 체크의 한계 인지하기**
  - 객체 리터럴을 변수할당/함수에 전달할 때 잉여속성 체크가 수행됨
  - `잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분`하여 이해(`다시 보고 이해할 것`)
  - 임시 변수를 도입하면 잉여 속성체크를 건너 뛸 수 있음(한계점)

**12. 함수 표현식에 타입 적용하기**
  - TS에서는 `함수 표현식`을 사용하는 것이 유리(매개변수, 반환값까지 함수 타입으로 선언, 재사용가능)
  - 함수 표현식 전체 타입을 정의하는 것이 간결
  - 타입 시그니쳐가 반복된다면 `함수 타입 분리 고려`
  - 다른 함수의 시그니처를 참조하려면 typeof fn 활용

**13. 타입과 인터페이스 차이점 알기**
  - 대부분의 경우 어떤걸 활용해도 문제 없음, but `차이를 이해하고 상황에 따라 같은 선택을 할 것(통일성)`
  - 유사 : 인덱스, 함수타입, 제네릭, 타입확장(interface는 주의사항 있음), 클래스 구현 가능
  - 차이 : interface는 union 대신 & 활용해야함, interface는 `보강(augment, 선언병합 등)`가능 -> 타입은 추가병합이 없을때 활용
  - 복잡하다면 타입, 둘다 활용 가능하다면 `일관성과 보강의 관점`에서 고려, `프로젝트의 일관성` 고려
  - API라면 병합고려해서 interface선호, 프로젝트 내부적으로는 선언병합이 없도록 설계하여 타입 선호

**14. 타입 연산과 제네릭 사용으로 반복 줄이기**
  - 타입에서도 DRY는 신경쓸 것, 기존의 코드작성에서 했던 것처럼 타입에서 `공유패턴 제거 메커니즘`을 경험할 것
  - interface들이 공통 필드가 있다면 기반 클래스로 분리
  - 타입 간 매핑을 위해 `keyof, typeof, 인덱싱, 매핑된 타입(pick 등)`활용 연습
  - 제네릭타입에서 함수 매개변수를 제한하는 방법 -> `extends`
  - pick, partial, ReturnType과 같은 제네릭 타입에 익숙해질 것

**15. 동적 데이터에 인덱스 시그니처 사용하기**
  - `다시 보고 이해할 것`
  ```ts
  type Rocket = {[property: string]: string}; //우항이 인덱스 시그니처
  ```
  - 런타입 때까지 객체의 속성 알 수 없을때 인덱스 시그니처 활용(csv파일 로드 등)
  - 안전을 위해 인덱스 시그니처 값 타입에 undefined 추가 고려
  - 가능하다면 interface, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입 선호

#### `Reference`
- 이펙티브 타입스크립트(인사이트, 댄 밴더캄)

