# Effective Typescript
***

틈틈이 하루 4~5개 / 반복, 프로젝트 경험 더 필요

***

## `Items`

**1. 타입스크립트와 자바스크립트의 관계 이해**
  - TS는 JS의 `상위집합` ( 모든 JS 프로그램은 TS 프로그램이다 ), TS가 타입을 위한 별도의 문법을 갖는다
  - JS의 런타임동작을 모델링, 런타임 오류를 미리 찾아내지만 타입체커가 모든 오류를 잡을 순 없음
  - JS에 엄격함을 더함

**2. 타입스크립트 설정 이해하기**
  - `tsconfig.json`을 활용하자 -> 동료들이나 도구가 TS 사용 계획을 파악할 수 있음
  - `noImplicitAny` -> 변수들이 미리 정의된 타입을 가져야하는지 여부 정의
  - `strictNullChecks` -> undefined, null가 모든 타입에 허용되는지 여부
  - strict 설정 더 알아보기

**3. 코드 생성과 타입이 관계없음을 이해하기**
  - TS 컴파일러
    - 최신버전으로 활용할 수 있게 구버전 JS를 Transpile
    - 코드의 타입 오류 체크
    - 위 두가지가 `독립적`임을 이해
      - 타입 오류가 있는 코드도 컴파일이 가능
      - 런타임에는 타입체크가 불가능
      - 타입연산은 런타임에 영향을 주지 않음
      - 런타임 타입은 선언된 타입과 다를 수 있음
      - TS 타입으로는 함수를 오버로드 할 수 없음(타입 수준만 가능)
      - TS 타입은 런타임 성능에 영향을 주지 않음

**4. 구조적 타이핑에 익숙해지기**
  - JS는 `Duck typing`기반, TS는 이를 모델링하기 위해 `구조적 타이핑` 사용
  - 클래스도 구조적 타이핑을 따름
  - 구조적 타이핑으로 `유닛 테스트` 편하게 가능, 라이브러리간 `의존성 분리`(ITEM 51)

**5. any타입 지양하기**
  - any의 위험성
    - any타입에는 타입 안정성이 없다
    - 함수 시그니쳐를 무시한다(약속된 파라미터, 리턴)
    - 언어 서비스가 적용되지 않는다(자동완성, 도움말 등)
    - 코드 리팩토링 시 버그를 감춤
    - 타입 설계를 감춤(상태객체의 설계 등, 설계가 명확하게 보이도록 타입을 일일이 작성할 것)
    - 타입시스템의 신뢰도 저하
  - any는 타입체커와 TS 언어 서비스를 무력하 시킨다

**6. 편집기를 사용하여 타입시스템 탐색**
  - `다시 보고 이해할 것`
  - TS 컴파일러(tsc) / TS 서버(tsserver)
  - 편집기에서 ts 언어 서비스를 적극 활용
  - 편집기로 `ts 시스템`, `ts 타입추론` 개념 잡을 것
  - 타입 선언파일을 찾아보는 방법 터득할 것(ts의 동작 모델링 방식 이해)

**7. 타입이 값들의 집합이라 생각할 것**
  - type은 `할당 가능한 값들의 집합`, 무한하거나(number,string) 유한함(boolean, literal)
  - 엄격한 상속관계가 아닌, 벤 다이어그램 식 표현임
  - A는 B를 상속, A는 B에 할당가능, A는 B의 서브타입 -> A는 B의 부분집합

**8. 타입공간과 값 공간의 심벌 구분하기**
  - 타입과 값의 이름이 같을 때, 구분하는 방법 익숙해 질 것
  - type, interface -> type
  - class, enum -> both
  - typeof, this, etc -> 타입과 값에서 다른 목적으로 활용될 수 있음

**9. 타입 단언보다는 타입 선언을 사용하기**
  ```ts
  interface Person{name: string};
  const alice: Person = {name: 'Alice'}; // 타입 선언
  const bob = {name: 'Bob'} as Person; // 타입 단언
  ```
  - 타입선언은 할당되는 값이 인터페이스를 만족하는지 검사, 속성 추가시도 확인
  - 타입단언이 필요한 경우
    - 타입체커의 추론보다 개발자가 판단하는 타입이 더 정확할때 ex) dom 엘리먼트에 대해
    - null 아니면 단언문
  - 화살표 함수의 반환 타입을 명시하는 법을 터득할 것(`다시 보고 이해할 것`)

**10. 객체 래퍼 타입 피하기**
  - JS는 기본형과 객체 타입을 자유롭게 변환함(기본형을 객체로 래핑->메소드 호출->래핑객체 버림)
  - 객체 래퍼 타입이 어떻게 쓰이는지 이해 요망(직접 사용, 인스턴스 생성 지양)
  - ts 객체 래퍼 타입 대신 기본형 타입 사용(String->string, Number->number, Boolean->boolean etc)

**11. 잉여 속성 체크의 한계 인지하기**
  - 객체 리터럴을 변수할당/함수에 전달할 때 잉여속성 체크가 수행됨
  - `잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분`하여 이해(`다시 보고 이해할 것`)
  - 임시 변수를 도입하면 잉여 속성체크를 건너 뛸 수 있음(한계점)

**12. 함수 표현식에 타입 적용하기**
  - TS에서는 `함수 표현식`을 사용하는 것이 유리(매개변수, 반환값까지 함수 타입으로 선언, 재사용가능)
  - 함수 표현식 전체 타입을 정의하는 것이 간결
  - 타입 시그니쳐가 반복된다면 `함수 타입 분리 고려`
  - 다른 함수의 시그니처를 참조하려면 typeof fn 활용

**13. 타입과 인터페이스 차이점 알기**
  - 대부분의 경우 어떤걸 활용해도 문제 없음, but `차이를 이해하고 상황에 따라 같은 선택을 할 것(통일성)`
  - 유사 : 인덱스, 함수타입, 제네릭, 타입확장(interface는 주의사항 있음), 클래스 구현 가능
  - 차이 : interface는 union 대신 & 활용해야함, interface는 `보강(augment, 선언병합 등)`가능 -> 타입은 추가병합이 없을때 활용
  - 복잡하다면 타입, 둘다 활용 가능하다면 `일관성과 보강의 관점`에서 고려, `프로젝트의 일관성` 고려
  - API라면 병합고려해서 interface선호, 프로젝트 내부적으로는 선언병합이 없도록 설계하여 타입 선호

**14. 타입 연산과 제네릭 사용으로 반복 줄이기**
  - 타입에서도 DRY는 신경쓸 것, 기존의 코드작성에서 했던 것처럼 타입에서 `공유패턴 제거 메커니즘`을 경험할 것
  - interface들이 공통 필드가 있다면 기반 클래스로 분리
  - 타입 간 매핑을 위해 `keyof, typeof, 인덱싱, 매핑된 타입(pick 등)`활용 연습
  - 제네릭타입에서 함수 매개변수를 제한하는 방법 -> `extends`
  - pick, partial, ReturnType과 같은 제네릭 타입에 익숙해질 것

**15. 동적 데이터에 인덱스 시그니처 사용하기**
  - `다시 보고 이해할 것`
  ```ts
  type Rocket = {[property: string]: string}; //우항이 인덱스 시그니처
  ```
  - 런타입 때까지 객체의 속성 알 수 없을때 인덱스 시그니처 활용(csv파일 로드 등)
  - 안전을 위해 인덱스 시그니처 값 타입에 undefined 추가 고려
  - 가능하다면 interface, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입 선호

**16. number 인덱스 시그니처보다는 `Array, tuple, ArrayLike 활용`하기**
  - 배열은 객체이므로 키는 숫자가 아니라 문자열임
  - 인덱스 시그니처로 사용된 number타입은 버그를 잡기 위한 순수 TS 코드
  - number를 인덱스 타입으로 사용하면 숫자 속성이 어떤 특별한 의미를 지닌다는 오해 가능

**17. 변경 관련된 오류 방지를 위해 `readonly` 사용하기**
  - readonly -> 요소를 쓸 수 없음, length를 읽을 수 있지만 바꿀 수 없음, 배열 변경(pop) 메소드 호출 불가
  - readonly선언 시 -> 함수내에 매개변수가 변화하는지 체크, 호출하는 쪽은 변하지않음을 보장, readonly배열을 매개변수로 넘길 수 있음
  - readonly 매개변수는 인터페이스를 명확하게, 변경으로 생기는 오류를 막음
  - const와 readonly의 차이를 이해할 것
  - readonly는 얕게 동작

**18. 매핑된 타입을 사용하여 값을 동기화하기**
  - 매핑된 타입을 사용해 `관련값과 타입을 동기화`
  - 인터페이스에 새 속성을 추가할 때, 선택을 강제하도록 매핑된 타입 고려
  - 매핑된 타입을 한 객체가 또 다른 객체와 정확히 같은 속성을 갖게 할 때 이상적
  - 매핑된 타입을 활용해 TS가 코드에 제약을 강제하도록 할 수 있음

**19. 추론 가능한 타입을 사용해 장황한 코드 방지하기**
  - 타입 추론이 가능하다면 명시적 타입구문을 필요하지 않음(쓰지 않는게 좋음)
  - TS는 복잡한 객체도 추론 가능
  - TS는 타입 추론에 최종 사용처를 고려하지 않고, 첫 등장에 결정됨
  - 이상적인 함수, 메서드의 시그니처에는 타입 구문이 있음
  - But 함수 내에서 생성된 지역 변수에는 타입구문을 넣지 않음, 로직에 집중
  - 반환타입을 명시하는 방법은, TDD와 유사함 / 반환타입을 명시하면 훨씬 직관적
  - 추론될 수 있는 경우에도 객체 리터럴과 함수반환에는 타입명시 고려 -> 내부 구현 오류 방지

**20. 다른 타입에는 다른 변수 사용하기**
  - 관점 : 변수의 값은 바뀔 수 있지만, 그 타입은 보통 바뀌지 않는다
  - 변수를 무분별하게 재사용하면 타입 체커와 개발자에게 혼란을 줄 수 있다
  - 별도 변수를 활용함이 바람직한 이유
    - 서로 관련이 없는 두개의 값을 분리
    - 변수명을 더 구체적으로 지을 수 있다
    - 타입 추론을 향샹, 타입 구문이 불필요해짐
    - 타입이 좀 더 간결해짐
    - let대신 const로 변수 선언 -> 코드 간결 / 타입체커 추론 유리

**21. 타입 넓히기**
  - `widening(넓히기)` -> 지정된 단일 값을 가지고 할당 가능한 값들의 집합을 유추해야함
  - 이해하면 오류원인 파악, 타입 구문에 대한 활용도 증대
  - TS가 제공하는 넓히기 과정 방법들
    - const(더 좁은 타입)
    - 타입 체커에 추가적인 문맥 제공(함수 매개변수로 값 전달 등)
    - const 단언문(혼동 주의) -> 온전히 타입 공간의 기법임
  - 동작에 영향을 줄 수 있는 방법인 `const, 타입 구문, 문맥, as const에 익숙해질 것`

**22. 타입 좁히기**
  - 일반적 예시 -> `null체크`
  - 분기문에서 `예외를 던지거나 함수를 반환`하여 블록의 나머지 부분에서 변수의 타입을 좁힐 수 있다.
  - `속성체크`로 타입을 좁힐 수 있다
  - 일부 `내장 함수`(isArray등)으로 타입을 좁힐 수 있다.
  - 명시적 `태그`를 붙임 -> `tagged union, discriminated union`

**23. 한꺼번에 객체 생성하기**
  - 속성을 제각각 추가하지말고 한꺼번에 객체로 만들어야 함
  - `객체 전개 연산자`로 큰 객체를 한꺼번에 만들어 낼 수 있음 / 타입 걱정없이 필드단위로 객체 생성도 가능
  - 객체에 조건부로 속성을 추가하는 방법을 익혀야함

**24. 일관성 있는 별칭(alias) 사용하기**
  - 별칭 남발은 `제어흐름 분석에 악영향`, 신중하게 활용할 것
  - TS가 타입을 좁히는 것을 방해함, 별칭 사용시 일관되어야 함
  - `비구조화 문법`을 사용해 일관된 이름을 사용할 것
  - 함수 호출이 객체 속성의 타입 정제를 무효화할 수 있음 주의
  - 속성보다 지역변수를 사용하면 타입 정제를 믿을 수 있음

**25. 비동기 코드에는 콜백 대신 async함수 사용하기**
  - 콜백보다 프로미스가 코드 작성이 쉬움, 타입추론이 쉬움
  - 즉시 사용가능한 값에 promise를 반환하는 것이 이상할 수 있지만 비동기 함수로 통일하는데 도움
    - 함수는 항상 동기/비동기로 수행되며 혼용되면 안됨
  - promise 생성보다 async/await 사용하는 것이 유리 -> 간결, 직관, 오류 제거에 유리
  - promise를 반환하는 함수라면 async로 선언하는 것이 유리


#### `Reference`
- 이펙티브 타입스크립트(인사이트, 댄 밴더캄)

